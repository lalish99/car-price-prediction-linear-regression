# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.500524Z","iopub.execute_input":"2023-03-30T05:14:31.500955Z","iopub.status.idle":"2023-03-30T05:14:31.510955Z","shell.execute_reply.started":"2023-03-30T05:14:31.500916Z","shell.execute_reply":"2023-03-30T05:14:31.509516Z"}}
# This Python 3 environment comes with many helpful analytics libraries installed
# It is defined by the kaggle/python Docker image: https://github.com/kaggle/docker-python
# For example, here's several helpful packages to load

import numpy as np # linear algebra
import pandas as pd # data processing, CSV file I/O (e.g. pd.read_csv)

# Input data files are available in the read-only "../input/" directory
# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directory

import os
for dirname, _, filenames in os.walk('/kaggle/input'):
    for filename in filenames:
        print(os.path.join(dirname, filename))

# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using "Save & Run All"
# You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.513451Z","iopub.execute_input":"2023-03-30T05:14:31.513945Z","iopub.status.idle":"2023-03-30T05:14:31.524272Z","shell.execute_reply.started":"2023-03-30T05:14:31.513890Z","shell.execute_reply":"2023-03-30T05:14:31.522982Z"}}
# Imports
import numpy
import pandas as pd

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.525713Z","iopub.execute_input":"2023-03-30T05:14:31.526093Z","iopub.status.idle":"2023-03-30T05:14:31.534082Z","shell.execute_reply.started":"2023-03-30T05:14:31.526057Z","shell.execute_reply":"2023-03-30T05:14:31.533014Z"}}
# Global variables

__errors__= [];  #global variable to store the errors/loss for visualisation

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.536471Z","iopub.execute_input":"2023-03-30T05:14:31.537658Z","iopub.status.idle":"2023-03-30T05:14:31.545569Z","shell.execute_reply.started":"2023-03-30T05:14:31.537618Z","shell.execute_reply":"2023-03-30T05:14:31.544405Z"}}
# Hypothesis function

def h(params, sample):
    """This evaluates a generic linear function h(x) with current parameters.  h stands for hypothesis

    Args:
        params (lst) a list containing the corresponding parameter for each element x of the sample
        sample (lst) a list containing the values of a sample

    Returns:
        Evaluation of h(x)
    """
    acum = 0
    for i in range(len(params)):
        acum = acum + params[i]*sample[i]  #evaluates h(x) = a+bx1+cx2+ ... nxn..
    return acum;

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.547067Z","iopub.execute_input":"2023-03-30T05:14:31.547562Z","iopub.status.idle":"2023-03-30T05:14:31.557829Z","shell.execute_reply.started":"2023-03-30T05:14:31.547523Z","shell.execute_reply":"2023-03-30T05:14:31.556599Z"}}
# Show errors function

def show_errors(params, samples,y):
    """Appends the errors/loss that are generated by the estimated values of h and the real value y

    Args:
        params (lst) a list containing the corresponding parameter for each element x of the sample
        samples (lst) a 2 dimensional list containing the input samples
        y (lst) a list containing the corresponding real result for each sample

    """
    global __errors__
    error_acum =0
    for i in range(len(samples)):
        hyp = h(params,samples[i])
        error = hyp - y[i]
        error_acum = + error**2 # this error is the original cost function, (the one used to make updates in GD is the derivated verssion of this formula)
    mean_error_param= error_acum / len(samples)
    __errors__.append(mean_error_param)

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.559401Z","iopub.execute_input":"2023-03-30T05:14:31.560428Z","iopub.status.idle":"2023-03-30T05:14:31.572333Z","shell.execute_reply.started":"2023-03-30T05:14:31.560373Z","shell.execute_reply":"2023-03-30T05:14:31.571287Z"}}
# Gradient Descent algorithm

def GD(params, samples, y, alfa):
    """Gradient Descent algorithm
    Args:
        params (lst) a list containing the corresponding parameter for each element x of the sample
        samples (lst) a 2 dimensional list containing the input samples
        y (lst) a list containing the corresponding real result for each sample
        alfa(float) the learning rate
    Returns:
        temp(lst) a list with the new values for the parameters after 1 run of the sample set
    """
    temp = list(params)
    for j in range( len(params) ):
        acum = 0
        for i in range(len(samples)):
            error = h( params, samples[i] ) - y[i]
            acum = acum + error * samples[i][j]  #Sumatory part of the Gradient Descent formula for linear Regression.
        temp[j] = params[j] - alfa * ( 1 / len(samples) ) * acum  #Subtraction of original parameter value with learning rate included.
    return temp

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.575165Z","iopub.execute_input":"2023-03-30T05:14:31.576307Z","iopub.status.idle":"2023-03-30T05:14:31.584896Z","shell.execute_reply.started":"2023-03-30T05:14:31.576260Z","shell.execute_reply":"2023-03-30T05:14:31.583419Z"}}
# Scaling

def scaling(samples):
    """Normalizes sample values so that gradient descent can converge
    Args:
        params (lst) a list containing the corresponding parameter for each element x of the sample
    Returns:
        samples(lst) a list with the normalized version of the original samples
    """
    acum =0
    samples = numpy.asarray(samples).T.tolist()   #[[1,1],[2,2],[3,3],[4,4],[5,5]]
    for i in range(1,len(samples)):
        for j in range(len(samples[i])):
            acum = acum + samples[i][j]
        avg = acum/(len(samples[i]))
        max_val = max(samples[i])
        for j in range(len(samples[i])):
            samples[i][j] = (samples[i][j] - avg)/max_val  #Mean scaling
    return numpy.asarray(samples).T.tolist()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.622420Z","iopub.execute_input":"2023-03-30T05:14:31.623321Z","iopub.status.idle":"2023-03-30T05:14:31.656048Z","shell.execute_reply.started":"2023-03-30T05:14:31.623276Z","shell.execute_reply":"2023-03-30T05:14:31.654817Z"}}
# Load Data
raw_data = pd.read_csv("/kaggle/input/car-data/CarPrice_Assignment.csv")
raw_data.head()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.700598Z","iopub.execute_input":"2023-03-30T05:14:31.701519Z","iopub.status.idle":"2023-03-30T05:14:31.725622Z","shell.execute_reply.started":"2023-03-30T05:14:31.701472Z","shell.execute_reply":"2023-03-30T05:14:31.724175Z"}}
# Create data subset to used fields
data = raw_data[[
    "fueltype",
    "doornumber",
    "carbody",
    "drivewheel",
    "enginelocation",
    "horsepower",
    "peakrpm",
    "aspiration",
    "cylindernumber",
    "enginesize"
]]
data

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:17:11.799503Z","iopub.execute_input":"2023-03-30T05:17:11.799902Z","iopub.status.idle":"2023-03-30T05:17:11.815594Z","shell.execute_reply.started":"2023-03-30T05:17:11.799865Z","shell.execute_reply":"2023-03-30T05:17:11.814534Z"}}
# Process data
# One hot encode
fuel_type_ohe = pd.get_dummies(data["fueltype"])
car_body_ohe = pd.get_dummies(data["carbody"])
drive_wheel_ohe = pd.get_dummies(data["drivewheel"])
engine_location_ohe = pd.get_dummies(data["enginelocation"])
aspiration_ohe = pd.get_dummies(data["aspiration"])

# Change written number to number
def encode_cylinder_number(cylinder_number):
    if cylinder_number == "four":
        return 4
    if cylinder_number == "six":
        return 6
    if cylinder_number == "five":
        return 5
    if cylinder_number == "eight":
        return 8
    if cylinder_number == "three":
        return 3
    if cylinder_number == "two":
        return 2
    if cylinder_number == "twelve":
        return 12
    raise Exception("Unkown cylinder number string", cylinder_number)
doornumber_number_original = data["doornumber"].apply(lambda x: encode_cylinder_number(x))
cylinder_number_original = data["cylindernumber"].apply(lambda x: encode_cylinder_number(x))

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:17:12.628623Z","iopub.execute_input":"2023-03-30T05:17:12.629794Z","iopub.status.idle":"2023-03-30T05:17:12.652030Z","shell.execute_reply.started":"2023-03-30T05:17:12.629724Z","shell.execute_reply":"2023-03-30T05:17:12.650495Z"}}
# Remove used columns for new data frame
used_columns = [
    "fueltype",
    "doornumber",
    "carbody",
    "drivewheel",
    "enginelocation",
    "aspiration",
    "cylindernumber"
]
numeric_data_original = data[data.columns.difference(used_columns)]

# Normalize numeric data with min-max normalization
numeric_data = (numeric_data_original-numeric_data_original.min())/(numeric_data_original.max()-numeric_data_original.min())

doornumber_number = (doornumber_number_original-doornumber_number_original.min())/(doornumber_number_original.max()-doornumber_number_original.min())
cylinder_number = (cylinder_number_original-cylinder_number_original.min())/(cylinder_number_original.max()-cylinder_number_original.min())

numeric_data.head()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.810948Z","iopub.execute_input":"2023-03-30T05:14:31.811704Z","iopub.status.idle":"2023-03-30T05:14:31.821249Z","shell.execute_reply.started":"2023-03-30T05:14:31.811654Z","shell.execute_reply":"2023-03-30T05:14:31.820294Z"}}
# Create y data
y_data = raw_data["price"]
y_data.head()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.871384Z","iopub.execute_input":"2023-03-30T05:14:31.872068Z","iopub.status.idle":"2023-03-30T05:14:31.898278Z","shell.execute_reply.started":"2023-03-30T05:14:31.872028Z","shell.execute_reply":"2023-03-30T05:14:31.896955Z"}}
# Create x data to use
frames = [
    fuel_type_ohe.reset_index(drop=True),
    doornumber_number.reset_index(drop=True),
    car_body_ohe.reset_index(drop=True),
    drive_wheel_ohe.reset_index(drop=True),
    engine_location_ohe.reset_index(drop=True),
    aspiration_ohe.reset_index(drop=True),
    cylinder_number.reset_index(drop=True),
    numeric_data.reset_index(drop=True)
]
x_data = pd.concat(frames, axis=1)
x_data.head()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.900353Z","iopub.execute_input":"2023-03-30T05:14:31.900712Z","iopub.status.idle":"2023-03-30T05:14:31.911302Z","shell.execute_reply.started":"2023-03-30T05:14:31.900677Z","shell.execute_reply":"2023-03-30T05:14:31.910002Z"}}
#  multivariate example trivial
params = numpy.zeros(len(x_data.columns) + 1)
samples = x_data.to_numpy().tolist()
y = y_data.to_numpy().tolist()

alfa =.01  #  learning rate
for i in range(len(samples)):
    if isinstance(samples[i], list):
        samples[i]=  [1]+samples[i]
    else:
        samples[i]=  [1,samples[i]]

# Check sizes
print(len(params))
print(len(samples[0]))
print(len(samples))
print(len(y))

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:31.913037Z","iopub.execute_input":"2023-03-30T05:14:31.913527Z","iopub.status.idle":"2023-03-30T05:14:43.791685Z","shell.execute_reply.started":"2023-03-30T05:14:31.913472Z","shell.execute_reply":"2023-03-30T05:14:43.790475Z"}}
epochs = 0

while True:  #  run gradient descent until local minima is reached
    oldparams = list(params)
    params=GD(params, samples,y,alfa)
    show_errors(params, samples, y)  #only used to show errors, it is not used in calculation
    epochs = epochs + 1
    if(oldparams == params or epochs == 500):   #  local minima is found when there is no further improvement
        break

import matplotlib.pyplot as plt  #use this to generate a graph of the errors/loss so we can see whats going on (diagnostics)
plt.plot(__errors__)
plt.show()

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:43.794313Z","iopub.execute_input":"2023-03-30T05:14:43.794685Z","iopub.status.idle":"2023-03-30T05:14:43.801246Z","shell.execute_reply.started":"2023-03-30T05:14:43.794650Z","shell.execute_reply":"2023-03-30T05:14:43.800039Z"}}
i = 0
for name in x_data.columns:
    print ("Parameter ", name, "value: ", params[i])
    i += 1
print ("Parameter  bias", "value: ", params[i])

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:43.803043Z","iopub.execute_input":"2023-03-30T05:14:43.803391Z","iopub.status.idle":"2023-03-30T05:14:43.818167Z","shell.execute_reply.started":"2023-03-30T05:14:43.803357Z","shell.execute_reply":"2023-03-30T05:14:43.816658Z"}}
available_fueltype = raw_data["fueltype"].unique()
available_doornumber = raw_data["doornumber"].unique()
available_carbody = raw_data["carbody"].unique()
available_drivewheel = raw_data["drivewheel"].unique()
available_enginelocation = raw_data["enginelocation"].unique()
available_aspiration = raw_data["aspiration"].unique()
available_cylindernumber = raw_data["cylindernumber"].unique()
print("Available Fuel Types: ", available_fueltype)
print("Available Door Number: ", available_doornumber)
print("Available Car Body: ", available_carbody)
print("Available Drive Wheel: ", available_drivewheel)
print("Available Engine Location: ", available_enginelocation)
print("Available Aspiration: ", available_aspiration)
print("Available Cylinder Number: ", available_cylindernumber)


# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:43.820140Z","iopub.execute_input":"2023-03-30T05:14:43.820547Z","iopub.status.idle":"2023-03-30T05:14:43.833790Z","shell.execute_reply.started":"2023-03-30T05:14:43.820505Z","shell.execute_reply":"2023-03-30T05:14:43.832327Z"}}
from enum import Enum

class FuelTypes(Enum):
    Gas = "gas"
    Diesel = "diesel"

class DoorNumberTypes(Enum):
    Two = 2
    Four = 4

class CarBodyTypes(Enum):
    Convertible = "convertible"
    Hatchback = "hatchback"
    Sedan = "sedan"
    Wagon = "wagon"
    HardTop = "hardtop"

class DriveWheelTypes(Enum):
    RearWheelDrive = "rwd"
    FrontWheelDrive = "fwd"
    FourWheelDrive = "4wd"

class EngineLocationTypes(Enum):
    Front = "front"
    Rear = "rear"

class AspirationTypes(Enum):
    Standard = "std"
    Turbo = "turbo"

class CylinderNumberTypes(Enum):
    Two = 2
    Three = 3
    Four = 4
    Five = 5
    Six = 6
    Eight = 8
    Twelve = 12

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:14:43.834950Z","iopub.execute_input":"2023-03-30T05:14:43.835338Z","iopub.status.idle":"2023-03-30T05:14:43.848839Z","shell.execute_reply.started":"2023-03-30T05:14:43.835290Z","shell.execute_reply":"2023-03-30T05:14:43.847769Z"}}
x_data.columns

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:17:41.997852Z","iopub.execute_input":"2023-03-30T05:17:41.998332Z","iopub.status.idle":"2023-03-30T05:17:42.032367Z","shell.execute_reply.started":"2023-03-30T05:17:41.998284Z","shell.execute_reply":"2023-03-30T05:17:42.031123Z"}}
def new_example(
    fueltype,
    doornumber,
    carbody,
    drivewheel,
    enginelocation,
    aspiration,
    cylindernumber,
    enginesize,
    horsepower,
    peakrpm,
):

    normalized_doornumber = (
        (doornumber.value-doornumber_number_original.min())
        /
        (doornumber_number_original.max()-doornumber_number_original.min())
    )
    normalized_cylindernumber = (
        (cylindernumber.value-cylinder_number_original.min())
        /
        (cylinder_number_original.max()-cylinder_number_original.min())
    )
    normalized_enginesize = (
        (enginesize-numeric_data_original["enginesize"].min())
        /
        (numeric_data_original["enginesize"].max()-numeric_data_original["enginesize"].min())
    )
    normalized_horsepower = (
        (enginesize-numeric_data_original["horsepower"].min())
        /
        (numeric_data_original["horsepower"].max()-numeric_data_original["horsepower"].min())
    )
    normalized_peakrpm = (
        (enginesize-numeric_data_original["peakrpm"].min())
        /
        (numeric_data_original["peakrpm"].max()-numeric_data_original["peakrpm"].min())
    )

    return [
        1 if fueltype == FuelTypes.Diesel else 0,
        1 if fueltype == FuelTypes.Gas else 0,
        normalized_doornumber,
        1 if carbody == CarBodyTypes.Convertible else 0,
        1 if carbody == CarBodyTypes.HardTop else 0,
        1 if carbody == CarBodyTypes.Hatchback else 0,
        1 if carbody == CarBodyTypes.Sedan else 0,
        1 if carbody == CarBodyTypes.Wagon else 0,
        1 if drivewheel == DriveWheelTypes.FourWheelDrive else 0,
        1 if drivewheel == DriveWheelTypes.FrontWheelDrive else 0,
        1 if drivewheel == DriveWheelTypes.RearWheelDrive else 0,
        1 if enginelocation == EngineLocationTypes.Front else 0,
        1 if enginelocation == EngineLocationTypes.Rear else 0,
        1 if aspiration == AspirationTypes.Standard else 0,
        1 if aspiration == AspirationTypes.Turbo else 0,
        normalized_cylindernumber,
        normalized_enginesize,
        normalized_horsepower,
        normalized_peakrpm,
    ]

data.head(1)

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:19:17.344608Z","iopub.execute_input":"2023-03-30T05:19:17.345053Z","iopub.status.idle":"2023-03-30T05:19:17.355817Z","shell.execute_reply.started":"2023-03-30T05:19:17.345016Z","shell.execute_reply":"2023-03-30T05:19:17.354399Z"}}
"""
fueltype,
doornumber,
carbody,
drivewheel,
enginelocation,
aspiration,
cylindernumber,
enginesize,
horsepower,
peakrpm,
"""

new_example_test = new_example(
    FuelTypes.Diesel,
    DoorNumberTypes.Four,
    CarBodyTypes.Sedan,
    DriveWheelTypes.RearWheelDrive,
    EngineLocationTypes.Rear,
    AspirationTypes.Standard,
    CylinderNumberTypes.Four,
    180,
    300,
    10000
)
new_example_test

# %% [code] {"execution":{"iopub.status.busy":"2023-03-30T05:19:18.050015Z","iopub.execute_input":"2023-03-30T05:19:18.050410Z","iopub.status.idle":"2023-03-30T05:19:18.058459Z","shell.execute_reply.started":"2023-03-30T05:19:18.050374Z","shell.execute_reply":"2023-03-30T05:19:18.057198Z"}}
h(params[0:-1], new_example_test) + params[-1]